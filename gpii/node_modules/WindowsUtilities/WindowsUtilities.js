/*
 * Windows Registry Settings Handler
 *
 * Copyright 2012 Raising the Floor - International
 * Copyright 2012 Antranig Basman
 * Copyright 2012 Astea Solutions AD
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

"use strict";

var ffi = require("ffi-napi"),
    child_process = require("child_process"),
    fluid = require("gpii-universal") /*,
    fs = require("fs"),
    path = require("path"),
    rimraf = require("rimraf")*/;

var gpii = fluid.registerNamespace("gpii");
var windows = fluid.registerNamespace("gpii.windows");

var ref = require("ref-napi");

var os = require("os");
var arch = os.arch();

/**
 * A map between Windows and C types.
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751%28v=vs.85%29.aspx
 */
windows.types = {
    "BOOL":   "int",
    "PBOOL":   "*int",
    "INT":    "int",
    "PINT":   ref.refType("int"),
    "UINT":   "uint",
    "PUINT":   ref.refType("uint"),
    "ULONG":  "ulong",
    "DWORD":  "ulong",
    "LPDWORD":  "*ulong",
    "HKL":    "void*",
    "ULONG_PTR": arch === "x64" ? "uint64" : "uint32",
    "LONG": "long",
    "HANDLE": arch === "x64" ? "uint64" : "uint32",
    "PVOID": ref.refType("void"),
    "WORD":   "uint16",
    "LUID": "uint64",
    // TODO: TCHAR should support Unicode and Windows code pages. We are just guessing
    // the system is using Unicode (wchar_t == uint16 type). The implementation should
    // support both modes.
    // https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx
    "TCHAR": "uint16",
    "PTCHAR": ref.refType("uint16"),
    "LP":    "void*"
};

var t = windows.types;

windows.kernel32 = ffi.Library("kernel32", {

    "GetLastError": [
        "uint32", []
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms724211%28v=vs.85%29.aspx
    "CloseHandle": [
        t.BOOL, [t.HANDLE]
    ],
    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684139.aspx
    "IsWow64Process": [
        t.BOOL,  [t.INT, t.PBOOL ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getlogicaldrivestringsw
    "GetLogicalDriveStringsW": [
        t.DWORD, [ t.DWORD, "char*" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdrivetypew
    "GetDriveTypeW": [
        t.UINT, [ "char*" ]
    ],
    // https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol
    "DeviceIoControl": [
        t.BOOL, [
            t.HANDLE,  // hDevice,
            t.DWORD,   // dwIoControlCode,
            t.PVOID,   // lpInBuffer,
            t.DWORD,   // nInBufferSize,
            t.PVOID,   // lpOutBuffer,
            t.DWORD,   // nOutBufferSize,
            t.LPDWORD, // lpBytesReturned,
            "int"      // lpOverlapped
        ]
    ],
    // https://msdn.microsoft.com/library/aa363858
    "CreateFileW": [
        t.HANDLE, [ "char*", t.DWORD, t.DWORD, t.HANDLE, t.DWORD, t.DWORD, t.HANDLE ]
    ],    
});

// Windows API constants delved from the unfathomable deeps of windows.h
windows.API_constants = {
    HKEY_CLASSES_ROOT:   0x80000000,
    HKEY_CURRENT_USER:   0x80000001,
    HKEY_LOCAL_MACHINE:  0x80000002,
    HKEY_USERS:          0x80000003,
    HKEY_CURRENT_CONFIG: 0x80000005,
    CP_UTF8: 65001,
    KEY_QUERY_VALUE: 1,
    KEY_SET_VALUE: 2,
    KEY_ENUMERATE_SUB_KEYS: 0x8,
    KEY_WOW64_32KEY: 0x200,
    KEY_WOW64_64KEY : 0x100,
    returnCodesLookup: {
        0: "ERROR_SUCCESS",
        1: "ERROR_INVALID_FUNCTION",
        2: "FILE_NOT_FOUND",
        3: "PATH_NOT_FOUND",
        6: "ERROR_INVALID_HANDLE",
        259: "ERROR_NO_MORE_ITEMS"
    },
    returnCodes: {},

    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms684880%28v=vs.85%29.aspx
    PROCESS_TERMINATE: 0x0001,
    PROCESS_QUERY_LIMITED_INFORMATION: 0x1000,
    PROCESS_QUERY_INFORMATION: 0x0400,
    PROCESS_VM_READ: 0x0010,

    // https://msdn.microsoft.com/library/ms685981
    SC_MANAGER_CONNECT: 0x0001,
    SERVICE_QUERY_STATUS : 0x0004,
    // https://msdn.microsoft.com/library/ms685996
    SERVICE_CONTINUE_PENDING: 0x00000005,
    SERVICE_PAUSE_PENDING: 0x00000006,
    SERVICE_PAUSED: 0x00000007,
    SERVICE_RUNNING: 0x00000004,
    SERVICE_START_PENDING: 0x00000002,
    SERVICE_STOP_PENDING: 0x00000003,
    SERVICE_STOPPED: 0x00000001,

    // http://stackoverflow.com/questions/23452271/is-max-path-always-same-size-even-if-unicode-macro-is-defined
    MAX_PATH: 260,
    MAX_NAME: 32,
    ENUM_CURRENT_SETTINGS: 0xffffffff,   // ((DWORD)-1)
    DISP_CHANGE_SUCCESSFUL: 0,
    DISP_CHANGE_RESTART: 1,
    FALSE:  0,
    TRUE:   1,
    // https://msdn.microsoft.com/library/windows/desktop/ms632641
    WM_QUIT: 0x12,
    // https://docs.microsoft.com/en-us/windows/desktop/winmsg/wm-close
    WM_CLOSE: 0x10,
    // https://docs.microsoft.com/windows/desktop/shutdown/wm-queryendsession
    WM_QUERYENDSESSION: 0x11,
    // https://docs.microsoft.com/windows/desktop/shutdown/wm-endsession
    WM_ENDSESSION: 0x16,
    // https://msdn.microsoft.com/library/ms912654
    WM_KEYDOWN: 0x100,
    // https://msdn.microsoft.com/library/ms646281
    WM_KEYUP: 0x101,
    // https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup
    WM_SYSKEYUP: 0x105,
    // https://msdn.microsoft.com/library/ms645616
    WM_MOUSEMOVE: 0x200,
    // https://msdn.microsoft.com/library/ms645608
    WM_LBUTTONUP: 0x202,
    // https://msdn.microsoft.com/library/ms646243
    WM_RBUTTONUP: 0x205,
    // https://docs.microsoft.com/windows/desktop/inputdev/wm-mousewheel
    WM_MOUSEWHEEL: 0x20A,

    // https://msdn.microsoft.com/library/aa363480
    WM_DEVICECHANGE: 0x219,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-user
    WM_USER: 0x400,
    // https://docs.microsoft.com/windows/desktop/dataxchg/wm-copydata
    WM_COPYDATA: 0x4a,

    // Registered messages
    WM_SHELLHOOK: "SHELLHOOK",

    HWND_BROADCAST: 0xffff,

    // https://docs.microsoft.com/windows/desktop/winmsg/wm-inputlangchange
    WM_INPUTLANGCHANGE: 0x51,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange
    WM_SETTINGCHANGE: 0x1a,
    // https://docs.microsoft.com/windows/desktop/hidpi/wm-dpichanged
    WM_DPICHANGED: 0x02E0,
    // https://docs.microsoft.com/windows/desktop/gdi/wm-syscolorchange
    WM_SYSCOLORCHANGE: 0x15,
    // https://docs.microsoft.com/windows/desktop/gdi/wm-displaychange
    WM_DISPLAYCHANGE: 0x7e,
    // https://docs.microsoft.com/windows/desktop/winmsg/wm-themechanged
    WM_THEMECHANGED: 0x31a,

    // https://docs.microsoft.com/windows/win32/inputdev/wm-activate
    WM_ACTIVATE: 0x0006,
    // https://docs.microsoft.com/windows/win32/winmsg/wm-windowposchanging
    WM_WINDOWPOSCHANGING: 0x0046,
    // https://docs.microsoft.com/windows/win32/winmsg/wm-windowposchanged
    WM_WINDOWPOSCHANGED: 0x0047,


    // https://docs.microsoft.com/windows/win32/winmsg/window-styles
    WS_VISIBLE: 0x10000000,
    // https://docs.microsoft.com/windows/win32/winmsg/extended-window-styles
    WS_EX_TOOLWINDOW: 0x00000080,

    // https://msdn.microsoft.com/library/aa363205
    DBT_DEVNODES_CHANGED: 0x7,
    DBT_DEVICEARRIVAL: 0x8000,
    DBT_DEVICEREMOVEPENDING: 0x8003,
    DBT_DEVICEREMOVECOMPLETE: 0x8004,
    DBT_DEVTYP_VOLUME: 0x2,

    // https://msdn.microsoft.com/library/dd375731
    virtualKeyCodes: {
        VK_LBUTTON: 0x01, // Left mouse button
        VK_RBUTTON: 0x02, // Right mouse button
        VK_CANCEL: 0x03, // Control-break processing
        VK_MBUTTON: 0x04, // Middle mouse button (three-button mouse)
        VK_XBUTTON1: 0x05, // X1 mouse button
        VK_XBUTTON2: 0x06, // X2 mouse button
        VK_BACK: 0x08, // BACKSPACE key
        VK_TAB: 0x09, // TAB key
        VK_CLEAR: 0x0C, // CLEAR key
        VK_RETURN: 0x0D, // ENTER key
        VK_SHIFT: 0x10, // SHIFT key
        VK_CONTROL: 0x11, // CTRL key
        VK_MENU: 0x12, // ALT key
        VK_PAUSE: 0x13, // PAUSE key
        VK_CAPITAL: 0x14, // CAPS LOCK key
        VK_KANA: 0x15, // IME Kana mode
        VK_HANGUL: 0x15, // IME Hangul mode
        VK_HANGUEL: 0x15, // IME Hanguel mode (maintained for compatibility; use VK_HANGUL)
        VK_JUNJA: 0x17, // IME Junja mode
        VK_FINAL: 0x18, // IME final mode
        VK_HANJA: 0x19, // IME Hanja mode
        VK_KANJI: 0x19, // IME Kanji mode
        VK_ESCAPE: 0x1B, // ESC key
        VK_CONVERT: 0x1C, // IME convert
        VK_NONCONVERT: 0x1D, // IME nonconvert
        VK_ACCEPT: 0x1E, // IME accept
        VK_MODECHANGE: 0x1F, // IME mode change request
        VK_SPACE: 0x20, // SPACEBAR
        VK_PAGEUP: 0x21, // PAGE UP key
        VK_PAGEDOWN: 0x22, // PAGE DOWN key
        VK_PRIOR: 0x21, // PAGE UP key
        VK_NEXT: 0x22, // PAGE DOWN key
        VK_END: 0x23, // END key
        VK_HOME: 0x24, // HOME key
        VK_LEFT: 0x25, // LEFT ARROW key
        VK_UP: 0x26, // UP ARROW key
        VK_RIGHT: 0x27, // RIGHT ARROW key
        VK_DOWN: 0x28, // DOWN ARROW key
        VK_SELECT: 0x29, // SELECT key
        VK_PRINT: 0x2A, // PRINT key
        VK_EXECUTE: 0x2B, // EXECUTE key
        VK_SNAPSHOT: 0x2C, // PRINT SCREEN key
        VK_INSERT: 0x2D, // INS key
        VK_DELETE: 0x2E, // DEL key
        VK_HELP: 0x2F, // HELP key
        VK_LWIN: 0x5B, // Left Windows key (Natural keyboard)
        VK_RWIN: 0x5C, // Right Windows key (Natural keyboard)
        VK_APPS: 0x5D, // Applications key (Natural keyboard)
        VK_SLEEP: 0x5F, // Computer Sleep key
        VK_NUMPAD0: 0x60, // Numeric keypad 0 key
        VK_NUMPAD1: 0x61, // Numeric keypad 1 key
        VK_NUMPAD2: 0x62, // Numeric keypad 2 key
        VK_NUMPAD3: 0x63, // Numeric keypad 3 key
        VK_NUMPAD4: 0x64, // Numeric keypad 4 key
        VK_NUMPAD5: 0x65, // Numeric keypad 5 key
        VK_NUMPAD6: 0x66, // Numeric keypad 6 key
        VK_NUMPAD7: 0x67, // Numeric keypad 7 key
        VK_NUMPAD8: 0x68, // Numeric keypad 8 key
        VK_NUMPAD9: 0x69, // Numeric keypad 9 key
        VK_MULTIPLY: 0x6A, // Multiply key
        VK_ADD: 0x6B, // Add key
        VK_SEPARATOR: 0x6C, // Separator key
        VK_SUBTRACT: 0x6D, // Subtract key
        VK_DECIMAL: 0x6E, // Decimal key
        VK_DIVIDE: 0x6F, // Divide key
        VK_F1: 0x70, // F1 key
        VK_F2: 0x71, // F2 key
        VK_F3: 0x72, // F3 key
        VK_F4: 0x73, // F4 key
        VK_F5: 0x74, // F5 key
        VK_F6: 0x75, // F6 key
        VK_F7: 0x76, // F7 key
        VK_F8: 0x77, // F8 key
        VK_F9: 0x78, // F9 key
        VK_F10: 0x79, // F10 key
        VK_F11: 0x7A, // F11 key
        VK_F12: 0x7B, // F12 key
        VK_F13: 0x7C, // F13 key
        VK_F14: 0x7D, // F14 key
        VK_F15: 0x7E, // F15 key
        VK_F16: 0x7F, // F16 key
        VK_F17: 0x80, // F17 key
        VK_F18: 0x81, // F18 key
        VK_F19: 0x82, // F19 key
        VK_F20: 0x83, // F20 key
        VK_F21: 0x84, // F21 key
        VK_F22: 0x85, // F22 key
        VK_F23: 0x86, // F23 key
        VK_F24: 0x87, // F24 key
        VK_NUMLOCK: 0x90, // NUM LOCK key
        VK_SCROLL: 0x91, // SCROLL LOCK key
        VK_LSHIFT: 0xA0, // Left SHIFT key
        VK_RSHIFT: 0xA1, // Right SHIFT key
        VK_LCONTROL: 0xA2, // Left CONTROL key
        VK_RCONTROL: 0xA3, // Right CONTROL key
        VK_LMENU: 0xA4, // Left MENU key
        VK_RMENU: 0xA5, // Right MENU key
        VK_BROWSER_BACK: 0xA6, // Browser Back key
        VK_BROWSER_FORWARD: 0xA7, // Browser Forward key
        VK_BROWSER_REFRESH: 0xA8, // Browser Refresh key
        VK_BROWSER_STOP: 0xA9, // Browser Stop key
        VK_BROWSER_SEARCH: 0xAA, // Browser Search key
        VK_BROWSER_FAVORITES: 0xAB, // Browser Favorites key
        VK_BROWSER_HOME: 0xAC, // Browser Start and Home key
        VK_VOLUME_MUTE: 0xAD, // Volume Mute key
        VK_VOLUME_DOWN: 0xAE, // Volume Down key
        VK_VOLUME_UP: 0xAF, // Volume Up key
        VK_MEDIA_NEXT_TRACK: 0xB0, // Next Track key
        VK_MEDIA_PREV_TRACK: 0xB1, // Previous Track key
        VK_MEDIA_STOP: 0xB2, // Stop Media key
        VK_MEDIA_PLAY_PAUSE: 0xB3, // Play/Pause Media key
        VK_LAUNCH_MAIL: 0xB4, // Start Mail key
        VK_LAUNCH_MEDIA_SELECT: 0xB5, // Select Media key
        VK_LAUNCH_APP1: 0xB6, // Start Application 1 key
        VK_LAUNCH_APP2: 0xB7, // Start Application 2 key
        VK_OEM_1: 0xBA, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the ';:' key
        VK_OEM_PLUS: 0xBB, // For any country/region, the '+' key
        VK_OEM_COMMA: 0xBC, // For any country/region, the ',' key
        VK_OEM_MINUS: 0xBD, // For any country/region, the '-' key
        VK_OEM_PERIOD: 0xBE, // For any country/region, the '.' key
        VK_OEM_2: 0xBF, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '/?' key
        VK_OEM_3: 0xC0, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '`~' key
        VK_OEM_4: 0xDB, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '[{' key
        VK_OEM_5: 0xDC, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the '\|' key
        VK_OEM_6: 0xDD, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the ']}' key
        VK_OEM_7: 0xDE, // Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the 'single-quote/double-quote' key
        VK_OEM_8: 0xDF, // Used for miscellaneous characters; it can vary by keyboard.
        VK_OEM_102: 0xE2, // Either the angle bracket key or the backslash key on the RT 102-key keyboard
        VK_PROCESSKEY: 0xE5, // IME PROCESS key
        VK_PACKET: 0xE7, // Used to pass Unicode characters as if they were keystrokes. The VK_PACKET key is the low word of a 32-bit Virtual Key value used for non-keyboard input methods. For more information, see Remark in KEYBDINPUT, SendInput, WM_KEYDOWN, and WM_KEYUP: -, // 0xE8
        VK_ATTN: 0xF6, // Attn key
        VK_CRSEL: 0xF7, // CrSel key
        VK_EXSEL: 0xF8, // ExSel key
        VK_EREOF: 0xF9, // Erase EOF key
        VK_PLAY: 0xFA, // Play key
        VK_ZOOM: 0xFB, // Zoom key
        VK_NONAME: 0xFC, // Reserved
        VK_PA1: 0xFD, // PA1 key
        VK_OEM_CLEAR: 0xFE // Clear key
    },

    // https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-keybdinput
    KEYEVENTF_EXTENDEDKEY: 1,
    KEYEVENTF_KEYUP: 2,
    KEYEVENTF_UNICODE: 4,
    KEYEVENTF_SCANCODE: 8,


    LLKHF_EXTENDED:  0x01,
    LLKHF_INJECTED:  0x10,
    LLKHF_ALTDOWN:   0x20,
    LLKHF_UP:        0x80,
    LLMHF_INJECTED:  0x01,

    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registershellhookwindow
    HSHELL_WINDOWCREATED: 1,
    HSHELL_WINDOWDESTROYED: 2,
    HSHELL_WINDOWACTIVATED: 4,
    HSHELL_RUDEAPPACTIVATED: 0x8004,

    // https://msdn.microsoft.com/library/ms646306
    MAPVK_VK_TO_CHAR: 2,

    // The AccessibilityTemp values; https://msdn.microsoft.com/library/windows/desktop/bb879984.aspx
    disableAT: 2,
    enableAT: 3,

    MONITOR_DEFAULTTOPRIMARY: 1,
    CCHDEVICENAME: 32,
    QDC_ONLY_ACTIVE_PATHS: 2,
    // https://msdn.microsoft.com/en-us/library/windows/hardware/ff554003.aspx
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED: 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED: 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL: 0x80000000,

    // https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getsyscolor
    COLOR_DESKTOP: 1,
    // https://msdn.microsoft.com/en-us/library/296az74e.aspx
    UINT_MAX: 0xffffffff,

    // https://msdn.microsoft.com/library/ms724947
    SpiFlags: {
        SPIF_UPDATEINIFILE: 0x1,
        SPIF_SENDCHANGE: 0x2
    },

    // https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics
    SM_CXSCREEN: 0,
    SM_CYSCREEN: 1,
    SM_CXDOUBLECLK: 36,
    SM_CYDOUBLECLK: 37,

    SM_SWAPBUTTON: 23,

    INVALID_HANDLE_VALUE: 0xffffffff,

    // https://docs.microsoft.com/en-us/windows/desktop/api/wingdi/ne-wingdi-displayconfig_topology_id
    DISPLAYCONFIG_TOPOLOGY_INTERNAL: 0,
    DISPLAYCONFIG_TOPOLOGY_CLONE: 1,
    DISPLAYCONFIG_TOPOLOGY_EXTEND: 2,
    DISPLAYCONFIG_TOPOLOGY_EXTERNAL: 3,
    DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32: 4,

    // https://docs.microsoft.com/es-es/windows/desktop/api/winuser/nf-winuser-setdisplayconfig
    SDC_TOPOLOGY_INTERNAL:            0x00000001,
    SDC_TOPOLOGY_CLONE:               0x00000002,
    SDC_TOPOLOGY_EXTEND:              0x00000004,
    SDC_TOPOLOGY_EXTERNAL:            0x00000008,
    SDC_TOPOLOGY_SUPPLIED:            0x00000010,

    SDC_VALIDATE:                     0x00000040,
    SDC_APPLY:                        0x00000080,

    // https://docs.microsoft.com/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa
    STARTF_USESHOWWINDOW: 0x1,
    // https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow
    SW_HIDE: 0,
    SW_SHOWNORMAL: 1,
    SW_SHOWMINIMIZED: 2,
    SW_SHOWMAXIMIZED: 3,
    SW_SHOWNOACTIVATE: 4,

    // https://docs.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shappbarmessage
    ABE_BOTTOM: 3,
    ABN_POSCHANGED: 1,
    ABM_NEW: 0x00000000,
    ABM_REMOVE: 0x00000001,
    ABM_SETPOS: 0x00000003,
    ABM_ACTIVATE: 0x00000006,
    ABM_WINDOWPOSCHANGED: 0x0000009


};

var c = windows.API_constants;

/**
 * Create a buffer containing the wide-character representation of string.
 * Used to convert strings to a buffer usable by the Windows API.
 *
 * @param {String} string The original string.
 * @return {Buffer} The buffer containing the UTF-16 string.
 */
windows.stringToWideChar = function (string) {
    return new Buffer(string + "\u0000", "ucs2"); // add null at the end
};

/**
 * Convert a buffer containing an array of wide-char strings, to an array of strings.
 *
 * The input array is a C style string array, where the values are separated by null characters. The array is terminated
 * by an additional 2 null characters.
 *
 * @param {Buffer} buffer The buffer to convert.
 * @return {Array<String>} An array of string.
 */
windows.stringFromWideCharArray = function (buffer) {
    var togo = [];
    var offset = 0;
    var current;
    do {
        current = ref.reinterpretUntilZeros(buffer, 2, offset);
        if (current.length) {
            togo.push(current.toString("ucs2"));
            offset += current.length + 2; // Extra 2 bytes is to skip the (wide) null separator
        }
    } while (current.length > 0);

    return togo;
};

/**
 * Determines whether this process is running under WoW64. That is, 32-bit node on 64-bit Windows.
 *
 * https://msdn.microsoft.com/en-us/library/windows/desktop/aa384249(v=vs.85).aspx
 *
 * @return {Boolean} true if this process is 32-bit, and the OS is 64-bit otherwise false.
 */
windows.isWow64 = function () {
    var ptr = ref.alloc(windows.types.DWORD);
    gpii.windows.kernel32.IsWow64Process(-1, ptr);
    return !!ptr.deref();
};

/**
 * Creates an error message for a win32 error.
 *
 * @param {String} message The message.
 * @param {String|Number} returnCode [optional] The return code of the function causing the error.
 * @param {String|Number} errorCode [optional] The last win32 error (from GetLastError), if already known.
 * @return {Error} The error message.
 */
windows.win32errorText = function (message, returnCode, errorCode) {
    var text = "win32 error: " + message;
    text += (returnCode === undefined) ? "" : (" return:" + returnCode);
    text += " win32:" + (errorCode || windows.kernel32.GetLastError());
    return text;
};

/**
 * Execute a command, ensuring it uses the native System32 directory instead of the 32-bit version.
 *
 * When running as a 32-bit process on a 64-bit OS, in order make sure the native version is executed the 64-bit
 * cmd.exe will be used to perform the invocation.
 *
 * @param {String} command The command to execute.
 * @param {Object} [options] The options for child_process.exec.
 * @param {function} [callback] Called when the process terminates.
 * @return {Object} Returns what child_process.exec returns.
 */
gpii.windows.nativeExec = function (command, options, callback) {
    var execOptions = fluid.extend({}, options);
    if (gpii.windows.isWow64()) {
        execOptions.shell = process.env.SYSTEMROOT + "\\Sysnative\\cmd.exe";
    }
    return child_process.exec(command, execOptions, callback);
};

/**
 * Gets a list of all drives on the system.
 * @return {Array<String>} Array of paths to each drive on the system (eg, "c:\")
 */
gpii.windows.getAllDrives = function () {
    var drivesBuffer = Buffer.alloc(0xff);
    windows.kernel32.GetLogicalDriveStringsW(drivesBuffer.length, drivesBuffer);

    var drives = windows.stringFromWideCharArray(drivesBuffer);

    return drives;
};

/**
 * Gets the USB drives that are available.
 *
 * @param {Array<String>} drivePaths [optional] Array of drives to check. Omit to check all drives on the system.
 * @return {Array<String>} Array of paths to each USB drive.
 */
gpii.windows.getUsbDrives = function (drivePaths) {
    var DRIVE_REMOVABLE = 2, DRIVE_FIXED = 3;
    var FILE_SHARE_READ = 1, FILE_SHARE_WRITE = 2;
    var OPEN_EXISTING = 3;
    var IOCTL_STORAGE_QUERY_PROPERTY = 0x2d1400;
    var BusTypeUsb = 7; // STORAGE_BUS_TYPE.BusTypeUsb

    // Get all the drives.
    var drives = drivePaths || gpii.windows.getAllDrives();

    drives = drives.filter(function (drivePath) {
        var busType = 0;
        var driveHandle = null;

        try {
            // GetDriveType is used to get a basic list of drives. This doesn't discriminate internal drives from usb
            // drives, but it does eliminate things like CD-ROM and network drives.
            var type = gpii.windows.kernel32.GetDriveTypeW(gpii.windows.stringToWideChar(drivePath));
            if (type === DRIVE_FIXED || type === DRIVE_REMOVABLE) {
                // Get a handle to the volume. Volume path is in the form of "\\.\A:"
                var volumePath = "\\\\.\\" + drivePath.substr(0, 2);
                driveHandle = gpii.windows.kernel32.CreateFileW(
                    gpii.windows.stringToWideChar(volumePath), 0, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);

                if (driveHandle === windows.API_constants.INVALID_HANDLE_VALUE) {
                    fluid.log("Unable to open the volume " + drivePath + ": "
                        + gpii.windows.win32errorText("CreateFileW", driveHandle));
                    driveHandle = null;
                }
            }

            if (driveHandle !== null) {
                // PropertyStandardQuery and StorageDeviceProperty is used for the query - both zeroes so just pass a buffer of
                // zeroes.
                var querySize = 12; // sizeof(STORAGE_PROPERTY_QUERY)
                var query = Buffer.alloc(querySize);
                query.fill(0);

                // Stores the resulting device descriptor
                var devDescSize = 40; // sizeof(STORAGE_DEVICE_DESCRIPTOR)
                var devDesc = Buffer.alloc(devDescSize);
                devDesc.fill(0);
                // Unused, but required.
                var byteCountBuffer = ref.alloc(gpii.windows.types.DWORD);

                // Get the device descriptor for the volume.
                var success = gpii.windows.kernel32.DeviceIoControl(
                    driveHandle,
                    IOCTL_STORAGE_QUERY_PROPERTY,
                    query, querySize,
                    devDesc, devDescSize,
                    byteCountBuffer.ref(), 0);

                if (success) {
                    // Get the busType from the device descriptor.
                    var busTypeOffset = 28;
                    busType = devDesc.readInt32LE(busTypeOffset);
                } else {
                    fluid.log("Unable to determine the bus type for drive " + drivePath + ": "
                        + gpii.windows.win32errorText("DeviceIoControl", success));
                }
            }

        } finally {
            if (driveHandle !== null) {
                gpii.windows.kernel32.CloseHandle(driveHandle);
            }
        }

        return busType === BusTypeUsb;
    });

    return drives;
};

exports.windows = windows;
